questions for zach TODO
example of how to split up the hash table doesn't really make sense to me
"Oncewedecidehowtodivideupthedata,wemayneedtoprocessadocumenton one machine and push the results off to other machines. What does this process look like? (Note: if we divide the hash table by document, this step may not be necessary.)" what does that mean?


Why Scripting Langauges can be good for technical interviews:
https://www.quora.com/Do-interviewers-frown-at-potential-hires-when-they-use-Ruby-or-Python-to-solve-an-interview-question-instead-of-C-C++-Java

JavaScript Implementations:
http://www.thatjsdude.com/interview/linkedList.html
https://github.com/redmacs/ctci-v6-javascript
https://github.com/gaylemcd/ctci/tree/master/javascript/lib/data-structures

Ruby Implementation:
https://github.com/JESii/CtCI-with-Ruby-TDD

Objective C
https://bitbucket.org/EslaMx7/ctci/src/7997d1f80809b99dcec2e12d1802c74f5e748559?at=master

It's like prepping for an exam. You understand the problems and solutions by practicing. Of course you can never understand EVERYTHING in computer science. Hence you just need to know all that you're prepping for.


https://github.com/MaximAbramchuck/awesome-interviews
https://github.com/MaximAbramchuck/awesome-interviews#ruby
https://github.com/MaximAbramchuck/awesome-interviews#ruby-on-rails
https://github.com/MaximAbramchuck/awesome-interviews#sql

More Ruby stuff
http://yehudakatz.com/2009/11/12/better-ruby-idioms/
http://www.railstips.org/blog/archives/2009/05/15/include-vs-extend-in-ruby/
https://matt.aimonetti.net/posts/2012/07/30/ruby-class-module-mixins/


Competitive and Practice Coding Sites:
Practice makes perfect! The more problems you do, the easier it will be to recognize and solve problems. - Gayle McDowell

https://projecteuler.net/archives
https://www.topcoder.com/
https://www.hackerrank.com/
http://www.spoj.com/


On Interviews
http://mattrogish.com/blog/2013/06/26/how-to-interview-programmers/
https://www.youtube.com/watch?v=aClxtDcdpsQ


Calculating for Big O (space complexity and time complexity)
http://stackoverflow.com/questions/18686121/differences-between-time-complexity-and-space-complexity
http://www.leda-tutorial.org/en/official/ch02s02s03.html
https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/


Big O in Ruby
http://www.sitepoint.com/data-structures-big-o-and-you/


recursive vs iterative approaches
http://programmers.stackexchange.com/questions/182314/recursion-or-while-loops
http://arstechnica.com/information-technology/2013/04/recursion-or-while-loops-which-is-better/



Computer Science Concepts
40 Key Computer Science Concepts Explained In Laymanâ€™s Terms
http://carlcheo.com/compsci#this-is-recursion-lol
http://www.datasciencecentral.com/profiles/blogs/36-computer-and-data-science-explained-in-layman-s-terms


=============== =============== =============== =============== 
Five Steps to a Technical Question

1. Askyour interviewer questions to resolve ambiguity.
2. Design an Algorithm.
Approach I: Examplify
derive a general rule from examples)
Approach II: Pattern Matching
we consider what problems the algorithm is similar to and try to modify the solution to the related problem to develop an algorithm for this problem (this requires understanding of different algorithms)
Approach III: Simplify and Generalize
simplify the problem. Then, we solve this new simplified version of the problem. Then adjust the solution to solve the complex version
Approach IV: Base Case and Build
 build a solution that can always compute the result for N if we know the correct result for N-1, then build the case for N-2, N-3, N-4 and build the solution. Base Case and Build algorithms often lead to natural recursive algorithms.
Approach V: Data Structure Brainstorm
simply run through a list of data structures and try to apply each one.  This approach is useful because solving a problem may be trivial once it occurs to us what solution to use. (this requires understanding of different algorithms)
3. Write pseudocode first, but make sure to tell your interviewer that you'll eventually write "real"code.
4. Write your code at a moderate pace.
5. Test your code and carefully fix any mistakes.





==================Sample Setup===================
Problem:


Clarification:

Assumptions:


Solutoin:


** OOD  **
Step 1: Handle Ambigulty
Step 2: Define the Core Objects
Step 3: Analyze Relationships
Step 4: Investigate Actions


** scalability memory **
Step 1: Make Believe
Step 2: Get Real
Step 3: Solve Problems








